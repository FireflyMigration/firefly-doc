<!DOCTYPE html>
<html lang="en" class="js flexbox flexboxlegacy canvas canvastext webgl no-touch geolocation postmessage websqldatabase indexeddb hashchange history draganddrop websockets rgba hsla multiplebgs backgroundsize borderimage borderradius boxshadow textshadow opacity cssanimations csscolumns cssgradients cssreflections csstransforms csstransforms3d csstransitions fontface generatedcontent video audio localstorage sessionstorage webworkers applicationcache svg inlinesvg smil svgclippaths">

<head>
    <meta http-equiv="X-UA-Compatible" content="IE=Edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta charset="utf-8" />
    <meta name="keywords" content="bulk insert">

    <title>Improve Performance of InsertIfNotFound using Memory Database and Bulk Copy</title>
    <link rel="shortcut icon" href="favicon.png" type="image/x-icon" />
    <link rel="stylesheet" href="assets/css/toc.css" />
    <link rel="stylesheet" href="assets/css/highlight.css" />
    <link rel="stylesheet" href="assets/css/prism.css" />
    <link rel="stylesheet" href="assets/css/prism-csdiff.css" />


    <link rel="stylesheet" href="assets/css/theme_firefly.css" />
    <link rel="stylesheet" href="assets/css/mermaid.css" />
</head>

<body class="markdown-body" role="document">
    <div class="wrapper" id="root">
        <div class="backdrop"></div>
        <div class="top-bar" role="navigation" aria-label="footer navigation">
            <div style="display:flex;">
                <div>
                    <a id="menu" class="btn btn-neutral">&#9776; </a>
                </div>
                <img src="assets/img/logo-big.png">
            </div>
            <div>
                <a id="previousButton" class="btn btn-neutral" style="visibility:hidden">Previous</a>
                <a id="nextButton" class="btn btn-neutral" style="visibility:hidden">Next</a>
            </div>
        </div>
        <div class="middle">

            <div class="container">

                <div class="content"><h1 id="improve-performance-of-insertifnotfound-using-memory-database-and-bulk-copy">Improve Performance of InsertIfNotFound using Memory Database and Bulk Copy</h1>
<p>Often we need to insert many rows to the database, while making sure that these rows don't already exist.
We use the <code>InsertIfNotFound</code> relation for that.</p>
<p>As the number of rows grows, the cost of checking in the db if the row exists, and inserting the rows one by one can be significant.</p>
<p>Let's use the following code as an example, it makes sure that all the customers in a specific country have an order</p>
<pre data-line="" class="language-csdiff line-numbers"><code>public class VerifyOrdersOfCustomer : BusinessProcessBase
{
    readonly Models.Customers Customers = new Models.Customers();
    readonly Models.Orders Orders = new Models.Orders();
    TextColumn _pCountry = new TextColumn();
        

    public VerifyOrdersOfCustomer()
    {
        From = Customers;
        Where.Add(Customers.Country.IsEqualTo(_pCountry));
        Relations.Add(Orders,RelationType.InsertIfNotFound, 
            Orders.CustomerID.BindEqualTo(Customers.CustomerID));
    }
    protected override void OnLeaveRow()
    {
          if (!Relations[Orders].RowFound)
          {
                Orders.OrderID.Value = 20000 + Counter;
                Orders.ShipCountry.Value = Customers.Country;
          }
    }
    public void Run(TextParameter country)
    {
        BindParameter(_pCountry, country);
        Execute();
    }
} </code></pre>
<p>We're going to change this code, so that instead of processing the rows one by one, we'll first load the relevant rows into memory,
We'll process them in memory, and save them to the db when we are done.</p>
<h3 id="step-1-change-our-orders-entity-and-make-it-memory-enabled">Step 1, change our Orders entity and make it memory enabled</h3>
<p>In the <code>Orders.cs</code> file we'll change its constructor and add another one</p>
<pre data-line="3,5" class="language-csdiff line-numbers"><code>
-public Orders() : base("dbo.Orders", "Orders", Shared.DataSources.Northwind) 
public Orders(bool inMemory) : base("dbo.Orders", "Orders", SqlHelper.GetMemoryOrReal(inMemory, Shared.DataSources.Northwind))
{...}
public Orders() : this(false) { } </code></pre>
<p>That way, when we create an instance of this class, we can decide if we want an in memory version of it.</p>
<blockquote>
<p>you can find the source of the <code>SqlHelper</code> class further done this article</p>
</blockquote>
<h3 id="step-2-adjust-our-controller">Step 2, adjust our controller</h3>
<p>Now we'll Change our controller to use the in memory version while it is running, and insert the rows once it's done</p>
<pre data-line="5,13,14,15" class="language-csdiff line-numbers"><code>public class VerifyOrdersOfCustomer : BusinessProcessBase
{
    readonly Models.Customers Customers = new Models.Customers();
    readonly Models.Orders Orders = new Models.Orders();
    readonly Models.Orders Orders = new Models.Orders(true);//the controller uses the in memory version of the code
    TextColumn _pCountry = new TextColumn();

...
    public void Run(TextParameter country)
    {
        BindParameter(_pCountry, country);
        Execute();
        var real = new Models.Orders();
        SqlHelper.CopyData(Orders, real);
        Orders.Truncate();//cleanup of the Orders in memory data
    }
} </code></pre>
<ol>
<li>We've changed the controller to use the in memory version of the table</li>
<li>Once the controller is done, we use the CopyData method to copy the in memory data to the database</li>
</ol>
<h2 id="the-copydata-method">The CopyData Method</h2>
<p>The <code>CopyData</code> method is optimized for performance. In fact - for SQL server it actually uses the BulkCopy option of Sql Server, improving the performance of inserting rows by more than 90%.
Instead of sending many insert statements, it sends all the data in a bulk.</p>
<h3 id="step-3-handling-existing-rows">Step 3, handling existing rows</h3>
<p>So far our example was good for only new rows, now we'll adjust it for existing rows as well.
Basically we'll start by loading the data of our range from the db, then before writing it - we'll delete its existing version in the database and insert the version that exists in memory.</p>
<pre data-line="5,6,7,8,9,10" class="language-csdiff line-numbers"><code>public void Run(TextParameter country)
{
    BindParameter(_pCountry, country);

    var real = new Models.Orders();
    var where = real.ShipCountry.IsEqualTo(country.Value);
    //copy the data from the database to the memory version
    SqlHelper.CopyData(real, Orders, where);
    //delete the data in the database before we insert the values from the memory
    real.Delete(where);

    Execute();
    //Insert the rows from the memory to the database
    SqlHelper.CopyData(Orders, real);
    Orders.Truncate();//cleanup of the Orders in memory data
} </code></pre>
<h2 id="sqlhelper-source">SqlHelper Source</h2>
<pre data-line="" class="language-csdiff line-numbers"><code>using ENV.Data;
using ENV.Data.DataProvider;
using Firefly.Box;
using Firefly.Box.Data.Advanced;
using Firefly.Box.Data.DataProvider;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace Northwind
{
    public class SqlHelper
    {
        public static IEntityDataProvider GetMemoryOrReal(bool useMemory, IEntityDataProvider originalConnection)
        {
            if (useMemory)
                return ENV.Data.DataProvider.MemoryDatabase.Instance;
            else
                return originalConnection;
        }
        public static void CopyData(Entity sourceTable, Entity targetTable, FilterBase sourceTableWhere = null)
        {
            using (ENV.Utilities.Profiler.StartContext("Copy Data To " + targetTable.GetType().Name))
            {
                #region Try use Sql Bulk Insert
                if (sourceTableWhere == null &amp;&amp; sourceTable.DataProvider is MemoryDatabase &amp;&amp; targetTable.DataProvider is DynamicSQLSupportingDataProvider)
                {
                    using (var c = ((DynamicSQLSupportingDataProvider)targetTable.DataProvider).CreateCommand())
                    {
                        var sqlConn = c.Connection as System.Data.SqlClient.SqlConnection;
                        if (sqlConn != null)
                        {
                            using (ENV.Utilities.Profiler.StartContext("Bulk Insert Into " + targetTable.GetType().Name))
                            {
                                var bc = new System.Data.SqlClient.SqlBulkCopy(sqlConn,
                                  System.Data.SqlClient.SqlBulkCopyOptions.
                                      KeepIdentity, (System.Data.SqlClient.SqlTransaction)c.Transaction);
                                bc.BulkCopyTimeout = 0;
                                bc.DestinationTableName = targetTable.EntityName;
                                foreach (var item in targetTable.Columns)
                                {
                                    if (!item.DbReadOnly)
                                        bc.ColumnMappings.Add(item.Name, item.Name);
                                }
                                bc.WriteToServer(((MemoryDatabase)sourceTable.DataProvider).DataSet.Tables[sourceTable.EntityName]);
                                return;
                            }
                        }
                    }
                }
                #endregion



                var bp = new BusinessProcess { From = sourceTable };
                if (sourceTableWhere != null)
                    bp.Where.Add(sourceTableWhere);
                bp.Relations.Add(targetTable, RelationType.Insert);
                bp.ForEachRow(() =&gt;
                {
                    foreach (var column in targetTable.Columns)
                    {
                        if (!column.DbReadOnly)
                        {
                            column.Value = sourceTable.Columns[column.Name];
                        }
                    }
                });
            }
        }
    }
} </code></pre>
<iframe width="560" height="315" src="https://www.youtube.com/embed/SHGamJfJhXY?list=PL1DEQjXG2xnJNtUHwUvmwYKay85F3WYMg" frameborder="0" allowfullscreen></iframe>



                    <hr />Help us improve,
                    <a href="https://github.com/FireflyMigration/firefly-doc/blob/master//30-Maintaining-the-Migrated-Application/50-Improve-Performance/00-Reduce-calls-to-the-database/07-Improving-InsertIfNotFound-Relation-using-InMemory-Database/02-Using-Temporary-In-Memory-Database.md" target="_blank">Edit this page on GitHub</a>
                    <br /> or email us at
                    <a href="mailto:info@fireflymigration.com?Subject=Firefly%20Documentation%20Website" target="_top">info@fireflymigration.com</a>
                </div>

                <!-- .content -->




            </div>
            <!-- .container-->

            <aside class="left-sidebar">
                <div class="wy-side-nav-search-ff">
                    <a href="" class="test">
                        
                    </a>
                </div>
                <div id="menuTree" </div>
            </aside>
            <!-- .left-sidebar -->

            <aside class="right-sidebar"></aside>
            <!-- .right-sidebar -->

            </div>
            <!-- .middle-->



        </div>


        <script src="assets/js/mermaid.js"></script>
        <script src="assets/js/prism-start.js"></script>
        <script src="assets/js/prism-clike.js"></script>
        <script src="assets/js/prism-markup.js"></script>
        <script src="assets/js/prism-css.js"></script>
        <script src="assets/js/prism-javascript.js"></script>

        <script src="assets/js/prism-diff.js"></script>
        <script src="assets/js/prism-csdiff.js"></script>
        <script src="assets/js/prism-function.js"></script>

        <script src="assets/js/jquery-3.1.1.js"></script>


        <script>
            (function (i, s, o, g, r, a, m) {
                i['GoogleAnalyticsObject'] = r; i[r] = i[r] || function () {
                    (i[r].q = i[r].q || []).push(arguments)
                }, i[r].l = 1 * new Date(); a = s.createElement(o),
                    m = s.getElementsByTagName(o)[0]; a.async = 1; a.src = g; m.parentNode.insertBefore(a, m)
            })(window, document, 'script', 'https://www.google-analytics.com/analytics.js', 'ga');

            ga('create', 'UA-4806432-3', 'auto');
            ga('send', 'pageview');

        </script>
        <script src="assets/js/tree.js"></script>
        <script language="javascript">
            buildTree('menuTree', 'using-temporary-in-memory-database.html', 'previousButton', 'nextButton');
        </script>
</body>

</html>
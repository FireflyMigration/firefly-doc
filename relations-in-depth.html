<!DOCTYPE html>
<html lang="en" class="js flexbox flexboxlegacy canvas canvastext webgl no-touch geolocation postmessage websqldatabase indexeddb hashchange history draganddrop websockets rgba hsla multiplebgs backgroundsize borderimage borderradius boxshadow textshadow opacity cssanimations csscolumns cssgradients cssreflections csstransforms csstransforms3d csstransitions fontface generatedcontent video audio localstorage sessionstorage webworkers applicationcache svg inlinesvg smil svgclippaths">

<head>
    <meta http-equiv="X-UA-Compatible" content="IE=Edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta charset="utf-8" />
    <meta name="keywords" content="">

    <title>Relations in depth</title>
    <link rel="shortcut icon" href="favicon.png" type="image/x-icon" />
    <link rel="stylesheet" href="assets/css/toc.css" />
    <link rel="stylesheet" href="assets/css/highlight.css" />
    <link rel="stylesheet" href="assets/css/prism.css" />
    <link rel="stylesheet" href="assets/css/prism-csdiff.css" />


    <link rel="stylesheet" href="assets/css/theme_firefly.css" />
    <link rel="stylesheet" href="assets/css/mermaid.css" />
</head>

<body class="markdown-body" role="document">
    <div class="wrapper" id="root">
        <div class="backdrop"></div>
        <div class="top-bar" role="navigation" aria-label="footer navigation">
            <div style="display:flex;">
                <div>
                    <a id="menu" class="btn btn-neutral">&#9776; </a>
                </div>
                <img src="assets/img/logo-big.png">
            </div>
            <div>
                <a id="previousButton" class="btn btn-neutral" style="visibility:hidden">Previous</a>
                <a id="nextButton" class="btn btn-neutral" style="visibility:hidden">Next</a>
            </div>
        </div>
        <div class="middle">

            <div class="container">

                <div class="content"><h1 id="relations-in-depth">Relations in depth</h1>
<p>In this article we are going to review different types of Relations in your migrated code and their interaction with the database. We'll look at the difference between Find (Find, Insert if not found) and Join (Left Outer Join, Inner Join) as well as the different SQL code that each one generates. We will also discuss optimizing the SQL code for Relations, by using Cache. This article doesn't address Insert relation type and InsertIfNotFound relation types. To read more about these topics, and get code samples please see: <a href="/reference/html/T_Firefly_Box_RelationType.htm">RelationType Documentation</a></p>
<h1 id="find-relation">Find Relation</h1>
<p>To start with, we'll create a simple UIController, which will display a list of products and it's Categories.</p>
<pre data-line="" class="language-csdiff line-numbers"><code>    class ShowProducts : UIControllerBase
    {
        internal readonly Model.Products _products = new Model.Products();
        internal readonly Model.Categories _categories = new Model.Categories()
        {
            Cached = true
        };
 
        public ShowProducts()
        {
            From = _products; 
 
            Relations.Add(_categories,RelationType.Find,
                _categories.CategoryID.IsEqualTo(_products.CategoryID),
                _categories.SortByCategoryName); 
 
            View = new UI.ShowProductsUI(this);
        }
 
        public void Run()
        {
            Execute();
        }
    } </code></pre>
<p>The .NET code displays this data on a form, as shown below:</p>
<p><img src="noname.jpg" alt="" /></p>
<p>Note that there are 15 lines on the grid displaying the first 15 lines from the Products Entity and a corresponding Category Name from the Category Relation. It is precisely this Category Relation that we will be looking at in this article in depth. As we progress, we will examine the SQL code for the Category Relation on each of these lines and understand the differences according to the Relation used and depending on whether Cache is enabled or not.</p>
<h2 id="viewing-the-sql">Viewing the SQL</h2>
<p>As a rule, a Relation is used to fetch related data from the database (or from Cache), for each row displayed in the grid. This rule applies whenever we enter a row, or whenever the values that define the Relation are changed (recompute). Now let's look into what goes on behind the scenes in the database, when we open this screen. The SQL code appears in the Output window. (For more details on the settings required to see SQL in the Output window, see: <a href="view-sql-output.html">View SQL Output</a> ).</p>
<p>Let's examine the SQL code in the Output screen. Here is the generated SQL code, as shown in the Output window, for all 15 lines displayed on the grid:</p>
<pre data-line="" class="language-csdiff line-numbers"><code>ExecuteNonQuery - sp_cursorprepexec
 
Query Parameters:
@handle(Int32) = 
@cursor(Int32) = 
@paramdef(String) = 
@stmt(String) = 
SELECT ProductID, ProductName, SupplierID, CategoryID, QuantityPerUnit, UnitPrice, UnitsInStock, UnitsOnOrder, ReorderLevel, Discontinued 
FROM dbo.Products 
ORDER BY ProductID
@scrollopt(Int32) = 135170
@ccopt(Int32) = 8193
@rowcount(Int32) = 
 
ExecuteNonQuery Duration..: 37.0021
ExecuteReader - sp_cursorfetch
 
Query Parameters:
@cursor(Int32) = 180150003
@fetchtype(Int32) = 2
@rownum(Int32) = 1
@nrows(Int32) = 40
 
ExecuteReader Duration: 2.0001
ExecuteReader - 
SELECT CategoryID, CategoryName, Description 
FROM dbo.Categories 
WHERE CategoryID = 5
 
ExecuteReader Duration..: 34.0019
ExecuteReader - 
SELECT CategoryID, CategoryName, Description 
FROM dbo.Categories 
WHERE CategoryID = 6
 
ExecuteReader Duration.: 13.0007
ExecuteReader - 
SELECT CategoryID, CategoryName, Description 
FROM dbo.Categories 
WHERE CategoryID = 2
 
ExecuteReader Duration: 0
ExecuteReader - 
SELECT CategoryID, CategoryName, Description 
FROM dbo.Categories 
WHERE CategoryID = 0
 
ExecuteReader Duration: 7.0004
ExecuteReader - 
SELECT CategoryID, CategoryName, Description 
FROM dbo.Categories 
WHERE CategoryID = 7
 
ExecuteReader Duration: 0
ExecuteReader - 
SELECT CategoryID, CategoryName, Description 
FROM dbo.Categories 
WHERE CategoryID = 4
 
ExecuteReader Duration: 6.0004
ExecuteReader - 
SELECT CategoryID, CategoryName, Description 
FROM dbo.Categories 
WHERE CategoryID = 1
 
ExecuteReader Duration.: 12.0007
ExecuteReader - 
SELECT CategoryID, CategoryName, Description 
FROM dbo.Categories 
WHERE CategoryID = 0
 
ExecuteReader Duration: 0 </code></pre>
<p>Note: It is possible to see the above information within the context of a logfile, by defining the following in the ini file:</p>
<p>dblogfile = c:\temp\db.log</p>
<p>For further information regarding using logfiles, see : <a href="using-log-files.html">Using Log Files</a></p>
<hr />
<h2 id="analyzing-the-sql">Analyzing the SQL</h2>
<p>Let's review each and every part of the above statements.</p>
<h3 id="first-statement">First statement</h3>
<p>This statement declares a server side cursor. The cursor contains a select statement for the main table that returns all the rows from the Product entity, as displayed below:</p>
<pre data-line="" class="language-csdiff line-numbers"><code>ExecuteNonQuery - sp_cursorprepexec
 
Query Parameters:
@handle(Int32) = 
@cursor(Int32) = 
@paramdef(String) = 
@stmt(String) = 
SELECT ProductID, ProductName, SupplierID, CategoryID, QuantityPerUnit, UnitPrice, UnitsInStock, UnitsOnOrder, ReorderLevel, Discontinued 
FROM dbo.Products 
ORDER BY ProductID
@scrollopt(Int32) = 135170
@ccopt(Int32) = 8193
@rowcount(Int32) =
 
ExecuteReader Duration .. : 81.0046 </code></pre>
<h3 id="second-statement">Second statement:</h3>
<p>This statement fetches the data from the cursor that was just declared, as displayed below:</p>
<pre data-line="" class="language-csdiff line-numbers"><code>ExecuteReader - sp_cursorfetch
 
Query Parameters:
@cursor(Int32) = 180150003
@fetchtype(Int32) = 2
@rownum(Int32) = 1
@nrows(Int32) = 40 </code></pre>
<h3 id="third-statement">Third statement</h3>
<p>This statement reflects that the program code is fetching data from the database using a Select command. This statement is the first one directly referring to the Relation that we defined.</p>
<pre data-line="" class="language-csdiff line-numbers"><code>ExecuteReader - 
SELECT CategoryID, CategoryName, Description 
FROM dbo.Categories 
WHERE CategoryID = 5
 
ExecuteReader Duration..: 34.0019 </code></pre>
<p>As you can see, the program is fetching data from the Categories Relation table, where CategoryID is equal to 5. This is the Category id for the first row, as displayed in the grid screenshot above. This statement is followed by many more similar statements, that fetch Categories for each product row. We will demonstrate the following principle: The select statement for the Relation is executed for each row displayed on the grid and if Cache is applied (as it is in this case), rows that were already fetched are not fetched again.</p>
<hr />
<h1 id="using-cache">Using Cache</h1>
<h2 id="introduction">Introduction</h2>
<p>When working with Relation Selects, you can enable Cache in order to optimize the number of direct queries to the Database. Once enabled, The UIController will try not to refetch rows with Related data directly from the DB that have already been fetched, but rather, will check the Cache first and fetch from there if possible.</p>
<h2 id="enabling-cache">Enabling Cache</h2>
<p>To enable Cache either in the Entity or in the Task, Type “Cached = true” either in the Entity or the Task, as displayed below.</p>
<p>In the entity:</p>
<pre data-line="" class="language-csdiff line-numbers"><code>        public Categories() : base("dbo.Categories", "Categories", DataSources.Northwind1)
        {
             Cached = true;
        } </code></pre>
<p>In the task:</p>
<pre data-line="" class="language-csdiff line-numbers"><code>        internal readonly Model.Categories _categories = new Model.Categories()
        {
            Cached = true,
        }; </code></pre>
<hr />
<h2 id="rules-for-working-with-cache">Rules for Working with Cache</h2>
<p>Even if you enable Cache, rows from a dB table will only be saved to the Cache if the following specific 3 conditions are met:</p>
<h3 id="unique-sort">Unique Sort</h3>
<p>A unique sort was declared for the Relation. For example, here is a unique sort, as defined in the Categories entity:</p>
<pre data-line="" class="language-csdiff line-numbers"><code>        public readonly Sort SortByCategoryID = new Sort
        {
        	Caption = "CategoryID",
        	Unique = true 
        } </code></pre>
<p>.. and here is the code that shows how the Relation declares this unique sort:</p>
<pre data-line="" class="language-csdiff line-numbers"><code>           Relations.Add(_categories,RelationType.Find,
                _categories.CategoryID.IsEqualTo(_products.CategoryID),
                _categories.SortByCategoryID); </code></pre>
<h3 id="use-all-segments">Use all Segments</h3>
<p>All the segments of the unique sort must be defined in the Relation's Where clause. For example, the code for this unique sort defines only one segment, CategoryID, as shown below, which the Relation Where clause uses, thus in this example, the Relation is using all segments.</p>
<pre data-line="" class="language-csdiff line-numbers"><code>  void InitializeIndexes()      
  {
 
      SortByCategoryID.Add(CategoryID);
  } </code></pre>
<p>If the unique index also included, let's say, the Category Name segment, then Category Name would also have to appear in the Relation code, in order for Cache to be enabled.</p>
<h3 id="implicit-use-of-primary-key-or-other-unique-index">Implicit Use of Primary key or other Unique Index</h3>
<p>Even if the Relation does not use a specifically specified unique sort, if the Where criteria for the Relation match any of the unique indexes of the entity or it's primary key, Cache will still be applied. For example, the CategoryID columns is defined as the primary key of the Categories entity:</p>
<pre data-line="" class="language-csdiff line-numbers"><code>class Categories : Entity 
    {
        [PrimaryKey(Identity = true)]
        public readonly NumberColumn CategoryID = new NumberColumn("CategoryID", "N10", "CategoryID")
        {
        	DbReadOnly = true
        };
   }; </code></pre>
<p>Notes:</p>
<p>If the Select statement doesn't return any row, nothing will be saved to the Cache. As a result, any further use of the same Select statement will be directed to the database.<br />
Note that if the “CacheNonUniqueResults” property is set to true, then regardless of unique key or primary key definitions, Caching will be enabled. The usage is as follows:</p>
<pre data-line="" class="language-csdiff line-numbers"><code>        internal readonly Model.Categories _categories = new Model.Categories()
        {
             CacheNonUniqueResults = true
        }; </code></pre>
<hr />
<h2 id="applying-the-cache-rules">Applying the Cache Rules</h2>
<p>Using our acquired knowledge, let's revisit the detailed SQL log displayed before.</p>
<h3 id="cached-true">Cached = true</h3>
<p>We can see that there are 8 Relation queries that the code generates, which return the required information for 15 rows on the grid. Thus, Cache saves 7 queries to the Database. To elaborate on this, let's reproduce the logic for each row:</p>
<ul>
<li>Product 1, Category 5 - Fetch the Relation from the dB.</li>
<li>Product 2, Category 6 - Fetch the Relation from the dB</li>
<li>Product 3, Category 2 - Fetch the Relation from the dB</li>
<li>Product 4, Category 0 - Fetch the Relation from the dB.</li>
<li>Product 5, Category 2 - Because the category was already fetched for product 3 and already exists in the Cache, no query to the DB is required.</li>
<li>Product 6, Category 2 - Already exists in Cache</li>
<li>Product 7, Category 7 - Fetch the Relation from the dB</li>
<li>Product 8, Category 2 - Already exists in Cache.</li>
<li>Product 9, Category 6 - Already exists in Cache.</li>
<li>Product 10, Category 2 - Already exists in Cache.</li>
<li>Product 11, Category 4 - Fetch the Relation from the dB.</li>
<li>Product 12, Category 4 - Already exists in Cache.</li>
<li>Product 13, Category 1, Fetch the Relation from the dB.</li>
<li>Product 14, Category 7, Already exists in Cache.</li>
<li>Product 15, Category 0 - Because no category was found when we asked for category 0 in product 4 - another query to the database is generated, in hope that a row will now be found.</li>
</ul>
<h3 id="cached-false">Cached = false</h3>
<p>Now let's change the Cache to false, and see the result.</p>
<pre data-line="" class="language-csdiff line-numbers"><code>         internal readonly Model.Categories _categories = new Model.Categories()
        {
            Cached = false
        }; </code></pre>
<p>After running the UIController, we'll get the following result containing 15 full dB SQL references, which clearly shows that we now access the Database for each row, regardless of whether the CategoryID has already appeared:</p>
<pre data-line="" class="language-csdiff line-numbers"><code>ExecuteNonQuery Duration: 0
ExecuteNonQuery - sp_cursorprepexec
 
Query Parameters:
@handle(Int32) = 
@cursor(Int32) = 
@paramdef(String) = 
@stmt(String) = 
SELECT ProductID, ProductName, SupplierID, CategoryID, QuantityPerUnit, UnitPrice, UnitsInStock, UnitsOnOrder, ReorderLevel, Discontinued 
FROM dbo.Products 
ORDER BY ProductID
@scrollopt(Int32) = 135170
@ccopt(Int32) = 8193
@rowcount(Int32) = 
 
ExecuteNonQuery Duration...: 55.0032
ExecuteReader - sp_cursorfetch
 
Query Parameters:
@cursor(Int32) = 180150003
@fetchtype(Int32) = 2
@rownum(Int32) = 1
@nrows(Int32) = 40
 
ExecuteReader Duration..: 20.0011
ExecuteReader - 
SELECT CategoryID, CategoryName, Description 
FROM dbo.Categories 
WHERE CategoryID = 5
 
ExecuteReader Duration..: 27.0016
ExecuteReader - 
SELECT CategoryID, CategoryName, Description 
FROM dbo.Categories 
WHERE CategoryID = 6
 
ExecuteReader Duration: 0
ExecuteReader - 
SELECT CategoryID, CategoryName, Description 
FROM dbo.Categories 
WHERE CategoryID = 2
 
ExecuteReader Duration: 1
ExecuteReader - 
SELECT CategoryID, CategoryName, Description 
FROM dbo.Categories 
WHERE CategoryID = 0
 
ExecuteReader Duration: 0
ExecuteReader - 
SELECT CategoryID, CategoryName, Description 
FROM dbo.Categories 
WHERE CategoryID = 2
 
ExecuteReader Duration: 0
ExecuteReader - 
SELECT CategoryID, CategoryName, Description 
FROM dbo.Categories 
WHERE CategoryID = 2
 
ExecuteReader Duration: 0
ExecuteReader - 
SELECT CategoryID, CategoryName, Description 
FROM dbo.Categories 
WHERE CategoryID = 7
 
ExecuteReader Duration: 0
ExecuteReader - 
SELECT CategoryID, CategoryName, Description 
FROM dbo.Categories 
WHERE CategoryID = 2
 
ExecuteReader Duration: 0
ExecuteReader - 
SELECT CategoryID, CategoryName, Description 
FROM dbo.Categories 
WHERE CategoryID = 6
 
ExecuteReader Duration: 0
ExecuteReader - 
SELECT CategoryID, CategoryName, Description 
FROM dbo.Categories 
WHERE CategoryID = 2
 
ExecuteReader Duration: 0
ExecuteReader - 
SELECT CategoryID, CategoryName, Description 
FROM dbo.Categories 
WHERE CategoryID = 4
 
ExecuteReader Duration: 0
ExecuteReader - 
SELECT CategoryID, CategoryName, Description 
FROM dbo.Categories 
WHERE CategoryID = 4
 
ExecuteReader Duration: 0
ExecuteReader - 
SELECT CategoryID, CategoryName, Description 
FROM dbo.Categories 
WHERE CategoryID = 1
 
ExecuteReader Duration: 0
ExecuteReader - 
SELECT CategoryID, CategoryName, Description 
FROM dbo.Categories 
WHERE CategoryID = 7
 
ExecuteReader Duration: 0
ExecuteReader - 
SELECT CategoryID, CategoryName, Description 
FROM dbo.Categories 
WHERE CategoryID = 0
 
ExecuteReader Duration: 0
ExecuteReader - 
SELECT CategoryID, CategoryName, Description 
FROM dbo.Categories 
WHERE CategoryID = 5 </code></pre>
<p>Note that we get the cursor for the main table and 15 more queries that are generated by the Relation for the grid, as well as one more addtional query for the row that we are parked on, a total of 16 SQL Relation quesries.</p>
<h3 id="no-primary-key-or-unique-sort">No Primary Key or Unique Sort</h3>
<p>Now let's switch Cached back to true, but also change the code in the Category entity so that CategoryID is no longer the primary key. Additionally, lets change the sort key for CategoryID to no longer be unique. (Note that in the code below “Unique = 'true' ” is commented out and the primary key is moved to the CategoryName field).</p>
<pre data-line="" class="language-csdiff line-numbers"><code>        [PrimaryKey(Identity = true)]
        public readonly NumberColumn CategoryID = new NumberColumn("CategoryID", "N10", "CategoryID")
        {
        	DbReadOnly = true
        }; 
 
        public readonly TextColumn CategoryName = new TextColumn("CategoryName", "15", "CategoryName");
 
        public readonly TextColumn Description = new TextColumn("Description", "10", "Description"); 
 
        public readonly Sort SortByCategoryName = new Sort
        {
        	Caption = "CategoryName"
        };
 
        public readonly Sort SortByCategoryID = new Sort
        {
        	Caption = "CategoryID",
        	//Unique = true
        }; </code></pre>
<p>As expected, when we run the UIController, Cache is no longer applied.</p>
<h3 id="unique-key-using-only-some-of-the-segments">Unique Key using only some of the segments</h3>
<p>Now let's redefine the SortByCategoryID to be unique, but let's add another segment, CategoryName, to this key. Note that the last line of code in the code below adds 2 segments to the SortByCategoryID key.</p>
<pre data-line="" class="language-csdiff line-numbers"><code>        public readonly Sort SortByCategoryID = new Sort
        {
        	Caption = "CategoryID",
        	Unique = true
        };
 
        /// &lt;summary&gt;Categories(E#5)&lt;/summary&gt;
        public Categories():base("dbo.Categories", "Categories", DataSources.Northwind1)
        {
            InitializeIndexes();
        }
 
        void InitializeIndexes()
        {
            SortByCategoryName.Add(CategoryName);
 
 
            SortByCategoryID.Add(CategoryID, CategoryName);
        } </code></pre>
<p>Once again if we run the UIController, Cache is not applied, since not all segments of the key are used in the Relation.</p>
<h3 id="recompute">Recompute</h3>
<p>On the row that we are parked on (product 1), le'ts change the Category from 5 to 7. As soon as we leave the CategoryID column, the Relation is re-evaluated, and a select statement to fetch row 7 is sent to the database:</p>
<p>ExecuteReader -
SELECT CategoryID, CategoryName, Description
FROM dbo.Categories
WHERE CategoryID = 7</p>
<p>ExecuteReader Duration: 2.0001
Of course if we were using Cache, and Category 7 existed in the Cache, we would not see the SQL statement, because it'll be fetched from the Cache.</p>
<hr />
<h1 id="left-outer-join">Left Outer Join</h1>
<p>Let's adjust the code to use outer join.</p>
<pre data-line="" class="language-csdiff line-numbers"><code> public ShowProducts()
        {
            From = _products;
            Relations.Add(_categories,RelationType.OuterJoin, 
                _categories.CategoryID.IsEqualTo(_products.CategoryID));
 
            View = new UI.ShowProductsUI(this);
        } </code></pre>
<p>Now that we run the program, the following SQL will be generated, as displayed in the output window and shown below:</p>
<pre data-line="" class="language-csdiff line-numbers"><code>ExecuteNonQuery - sp_cursorprepexec
 
Query Parameters:
@handle(Int32) = 
@cursor(Int32) = 
@paramdef(String) = 
@stmt(String) = 
SELECT A.ProductID, A.ProductName, A.SupplierID, A.CategoryID, A.QuantityPerUnit, A.UnitPrice, A.UnitsInStock, A.UnitsOnOrder, A.ReorderLevel, A.Discontinued, B.CategoryID, B.CategoryName, B.Description 
FROM dbo.Products A 
  LEFT OUTER JOIN dbo.Categories B ON B.CategoryID = A.CategoryID 
ORDER BY A.ProductID
@scrollopt(Int32) = 135170
@ccopt(Int32) = 8193
@rowcount(Int32) = 
 
ExecuteNonQuery Duration...: 53.0031 </code></pre>
<p>Looking at the above, we can see that there is initial overhead on the Relation code but this is followed by no further SQL Select statements for rows. Using Outer Join can therefore potentially lead to a significant increase in performance, specifically when working with smaller tables.</p>
<hr />
<h2 id="recompute-1">Recompute</h2>
<p>If the CategoryID is updated and a recompute has to occur in order to update the CategoryName, then a RELATION SQL statement will be executed according to the rules of FIND Relations and CACHE. For example, if the CategoryID on a row is updated to 1, then the following SQL can be seen on the output screen.</p>
<pre data-line="" class="language-csdiff line-numbers"><code>ExecuteReader - 
SELECT top 1 CategoryID, CategoryName, Description 
FROM dbo.Categories 
WHERE CategoryID = 1 
ORDER BY CategoryID, CategoryName
 
ExecuteReader Duration: 3.0002 </code></pre>
<hr />
<h1 id="inner-join">Inner Join</h1>
<p>Now let's change the Relation type to Inner Join as displayed below: (note that Join, by default, implies Inner Join)</p>
<pre data-line="" class="language-csdiff line-numbers"><code>        public ShowProducts()
        {
            From = _products;
            Relations.Add(_categories,RelationType.Join,
                _categories.CategoryID.IsEqualTo(_products.CategoryID));
 
            View = new UI.ShowProductsUI(this);
        } </code></pre>
<p>In this case, in terms of an initial Join followed by no further Select statements, the SQL will be similar to the previous example of Outer Join and looks as follows:</p>
<pre data-line="" class="language-csdiff line-numbers"><code>ExecuteNonQuery - sp_cursorprepexec
 
Query Parameters:
@handle(Int32) = 
@cursor(Int32) = 
@paramdef(String) = 
@stmt(String) = 
SELECT A.ProductID, A.ProductName, A.SupplierID, A.CategoryID, A.QuantityPerUnit, A.UnitPrice, A.UnitsInStock, A.UnitsOnOrder, A.ReorderLevel, A.Discontinued, B.CategoryID, B.CategoryName, B.Description 
FROM dbo.Products A 
  INNER JOIN dbo.Categories B ON B.CategoryID = A.CategoryID 
ORDER BY A.ProductID
@scrollopt(Int32) = 135170
@ccopt(Int32) = 8193
@rowcount(Int32) = 
 
ExecuteNonQuery Duration..: 34.0019 </code></pre>
<p>This being the case, Cache is not required for Relations. Of course, in this case, only product rows that have a categoryID that exists also in the categories table will be displayed as shown below:</p>
<p><img src="capture1.jpg" alt="" /></p>
<p>Rows with ProductID 4 and Row 15 have CategoryID = 0 which does not appear in the Categories table, so these rows are thus not displayed.</p>
<h2 id="recompute-2">Recompute</h2>
<p>As is the case with Outer Join, if the CategoryID is updated and a recompute has to occur in order to update the CategoryName, then a RELATION SQL statement will be executed according to the rules of FIND Relations and CACHE. For example, if the CategoryID on a row is updated to 1, then the following SQL can be seen on the output screen.</p>
<pre data-line="" class="language-csdiff line-numbers"><code>ExecuteReader - 
SELECT top 1 CategoryID, CategoryName, Description 
FROM dbo.Categories 
WHERE CategoryID = 1 
ORDER BY CategoryID, CategoryName
 
ExecuteReader Duration: 1 </code></pre>



                    <hr />Help us improve,
                    <a href="https://github.com/FireflyMigration/firefly-doc/blob/master//20-Getting-Familiar-with-Migrated-Code/50-DataAccess/30-Relations-in-depth/index.md" target="_blank">Edit this page on GitHub</a>
                    <br /> or email us at
                    <a href="mailto:info@fireflymigration.com?Subject=Firefly%20Documentation%20Website" target="_top">info@fireflymigration.com</a>
                </div>

                <!-- .content -->




            </div>
            <!-- .container-->

            <aside class="left-sidebar">
                <div class="wy-side-nav-search-ff">
                    <a href="" class="test">
                        
                    </a>
                </div>
                <div id="menuTree" </div>
            </aside>
            <!-- .left-sidebar -->

            <aside class="right-sidebar"></aside>
            <!-- .right-sidebar -->

            </div>
            <!-- .middle-->



        </div>


        <script src="assets/js/mermaid.js"></script>
        <script src="assets/js/prism-start.js"></script>
        <script src="assets/js/prism-clike.js"></script>
        <script src="assets/js/prism-markup.js"></script>
        <script src="assets/js/prism-css.js"></script>
        <script src="assets/js/prism-javascript.js"></script>

        <script src="assets/js/prism-diff.js"></script>
        <script src="assets/js/prism-csdiff.js"></script>
        <script src="assets/js/prism-function.js"></script>

        <script src="assets/js/jquery-3.1.1.js"></script>


        <script>
            (function (i, s, o, g, r, a, m) {
                i['GoogleAnalyticsObject'] = r; i[r] = i[r] || function () {
                    (i[r].q = i[r].q || []).push(arguments)
                }, i[r].l = 1 * new Date(); a = s.createElement(o),
                    m = s.getElementsByTagName(o)[0]; a.async = 1; a.src = g; m.parentNode.insertBefore(a, m)
            })(window, document, 'script', 'https://www.google-analytics.com/analytics.js', 'ga');

            ga('create', 'UA-4806432-3', 'auto');
            ga('send', 'pageview');

        </script>
        <script src="assets/js/tree.js"></script>
        <script language="javascript">
            buildTree('menuTree', 'relations-in-depth.html', 'previousButton', 'nextButton');
        </script>
</body>

</html>